name: cijobs
on:
  push:
    branches: 
      - 'main'
      - 'monitoring' # test branch
    paths:
      - "src/**"
      - ".github/workflows/**"
      - "Dockerfile"           # Docker build file changes
      - "pom.xml"              # pom project changes
      - ".mvn/**"              # Maven wrapper changes
      - "mvnw"                 # 
      - "mvnw.cmd"             # 
  pull_request:
    paths:
      - "src/**"
      - ".github/workflows/**"
      - "Dockerfile"
      - "pom.xml"

env:
  IMAGE_REG: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  APP_NAME: build-test-contain
  GIT_MONITOR: github-exporter

jobs:
  test:
    name: Tests & Linting
    runs-on: ubuntu-latest
    permissions:
      contents: write  # needed for gh-pages branch to write coverage reports
      checks: write      # Add this for publishing test results
      pull-requests: write  # Add this for PR comments
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Run linting
        run: mvn checkstyle:check
      
      - name: Run tests with JaCoCo
        run: mvn clean test jacoco:report
      
      - name: Generate JaCoCo Badge
        id: jacoco
        uses: cicirello/jacoco-badge-generator@v2
        with:
          badges-directory: badges
          generate-branches-badge: true
          generate-summary: true
      
      - name: Log coverage percentage
        run: |
          echo "coverage = ${{ steps.jacoco.outputs.coverage }}"
          echo "branch coverage = ${{ steps.jacoco.outputs.branches }}"
      
      - name: Upload JaCoCo coverage report
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-report
          path: target/site/jacoco/
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./target/site/jacoco/jacoco.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}
      
      - name: Publish coverage report to GitHub Pages
        uses: JamesIves/github-pages-deploy-action@v4
        if: github.ref == 'refs/heads/main'
        with:
          branch: gh-pages
          folder: target/site/jacoco
          target-folder: coverage
      
      - name: Add coverage comment to PR
        uses: madrapps/jacoco-report@v1.6.1
        if: github.event_name == 'pull_request'
        with:
          paths: ${{ github.workspace }}/target/site/jacoco/jacoco.xml
          token: ${{ secrets.GITHUB_TOKEN }}
          min-coverage-overall: 50
          min-coverage-changed-files: 60
      
      - name: Upload test results # put them in the repo for download
        uses: actions/upload-artifact@v4
        if: ${{ always() && !env.ACT }}
        with:
          name: test-results
          path: target/surefire-reports/*.xml

  build:
    name: Build Push Image
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Build with Maven
        run: mvn clean package -DskipTests
      
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.IMAGE_REG }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_REG }}/${{ env.IMAGE_NAME }}
      
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      
      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ env.IMAGE_REG }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

      - name: Send Slack Success Notification
        if: success()
        uses: slackapi/slack-github-action@v2.0.0
        id: slack_notify_pass
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          errors: true
          payload: |
            text: "✅ Build succeeded for *${{ github.repository }}* on branch *${{ github.ref_name }}* by *${{ github.actor }}*"
          
      - name: Send Slack failure Notification
        if: failure()
        uses: slackapi/slack-github-action@v2.0.0
        id: slack_notify_fail
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          errors: true
          payload: |
            text: "Build failed for *${{ github.repository }}* on branch *${{ github.ref_name }}* by *${{ github.actor }}*"

      - name: Print Slack response
        run: |
          echo "Slack OK: ${{ steps.slack_notify.outputs.ok }}"
          echo "Slack response: ${{ steps.slack_notify.outputs.response }}"

  vulnerability_scans:
    name: trivy to check container image
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
      security-events: write # needs wrtite access to events
    steps:
    # checkout
      - name: Checkout code
        uses: actions/checkout@v4
    # Trivy step 1st pass 
      - name: Run Trivy vulnerability scanner 1st pass
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.IMAGE_REG }}/${{ env.IMAGE_NAME }}:main'
          hide-progress: false
          format: 'sarif'
          output: 'trivy-results.sarif'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

      - name: Run Trivy vulnerability scanner 2nd pass
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.IMAGE_REG }}/${{ env.IMAGE_NAME }}:main'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'  # upload to github result

      - name: Send Slack Success Notification
        if: success()
        uses: slackapi/slack-github-action@v2.0.0
        id: slack_notify_trivy_ok
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          errors: true
          payload: |
            text: "✅ Trivy succeeded for *${{ github.repository }}* on branch *${{ github.ref_name }}* by *${{ github.actor }}*"
          
      - name: Send Slack failure Notification
        if: failure()
        uses: slackapi/slack-github-action@v2.0.0
        id: slack_notify_trivy_fail
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          errors: true
          payload: |
            text: "Trivy failed for *${{ github.repository }}* on branch *${{ github.ref_name }}* by *${{ github.actor }}*"

      - name: Print Slack response
        run: |
          echo "Slack OK: ${{ steps.slack_notify.outputs.ok }}"
          echo "Slack response: ${{ steps.slack_notify.outputs.response }}"

  vps:
    name: VPS push image
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_PORT }}
          passphrase: ${{ secrets.VPS_PHRASE }}
          script: |
            # Navigate to app directory
            cd /opt/${{ env.APP_NAME }} || mkdir -p /opt/${{ env.APP_NAME }} && cd /opt/${{ env.APP_NAME }}

            # Create .env file from secrets
            cat > .env << EOF
            GHCR_USERNAME=${{ github.actor }}
            APP_NAME=${{ env.APP_NAME }}
            EOF

            rm docker-compose-vps.yml
            # Download docker-compose-vps.yml if it doesn't exist
            if [ ! -f docker-compose-vps.yml ]; then
              curl -o docker-compose-vps.yml https://raw.githubusercontent.com/obsidionz/build-test-contain/refs/heads/main/docker-compose-vps.yml
            fi

            export GHCR_TOK="${{ secrets.GHCR_PAT }}"
            echo "$GHCR_TOK" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
            GHCR_TOK=
            # Pull latest image
            docker compose -f docker-compose-vps.yml --env-file .env pull

            # Stop and remove old containers
            docker compose -f docker-compose-vps.yml --env-file .env down

            # Start new containers
            docker compose -f docker-compose-vps.yml --env-file .env up -d

            # Clean up old images
            docker image prune -f

  monitoring:
    name: monitor github stats
    needs: vps
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: run install container github exporter on VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_PORT }}
          passphrase: ${{ secrets.VPS_PHRASE }}
          script: |
            # Navigate to app directory
            cd /opt/${{ env.GIT_MONITOR }} || mkdir -p /opt/${{ env.GIT_MONITOR }} && cd /opt/${{ env.GIT_MONITOR }}

            # Create .env file from secrets
            cat > .env << EOF
            GF_SECURITY_ADMIN_PASSWORD=${{ secrets.GRAF_PWD }}
            GF_USERS_ALLOW_SIGN_UP=false
            GHCR_USERNAME=${{ github.actor }}
            GITHUB_EXPORTER_TOKEN=${{ secrets.GHCR_PAT }}
            EOF

            rm docker-compose-monitor.yml
            # Download docker-compose-monitor.yml if it doesn't exist
            if [ ! -f docker-compose-monitor.yml ]; then
              curl -o docker-compose-monitor.yml https://raw.githubusercontent.com/obsidionz/build-test-contain/${{ github.ref_name }}/docker-compose-monitor.yml
            fi
            cd /opt/${{ env.GIT_MONITOR }}/prometheus || mkdir -p /opt/${{ env.GIT_MONITOR }}/prometheus && cd /opt/${{ env.GIT_MONITOR }}/prometheus
            rm prometheus.yml
            # Download prometheus config for data sources
            if [ ! -f prometheus.yml ]; then
              curl -o prometheus.yml https://raw.githubusercontent.com/obsidionz/build-test-contain/${{ github.ref_name }}/prometheus/prometheus.yml
              cd ..
            fi
            # Download grafana dashboard to prometheus data for github stats
            cd /opt/${{ env.GIT_MONITOR }}/grafana || mkdir -p /opt/${{ env.GIT_MONITOR }}/grafana && cd /opt/${{ env.GIT_MONITOR }}/grafana
            cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning || mkdir -p /opt/${{ env.GIT_MONITOR }}/grafana/provisioning && cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning
            cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning/dashboards || mkdir -p /opt/${{ env.GIT_MONITOR }}/grafana/provisioning/dashboards && cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning/dashboards
            rm dashboard_L00196753.json
            rm dashboard.yml
            # Download dashboard config for grafana
            if [ ! -f dashboard.yml ]; then 
              curl -o dashboard.yml https://raw.githubusercontent.com/obsidionz/build-test-contain/${{ github.ref_name }}/grafana/dashboard.yml
              curl -o dashboard_L00196753.json https://raw.githubusercontent.com/obsidionz/build-test-contain/${{ github.ref_name }}/grafana/dashboard_L00196753.json           
              cd ../../..
            fi
            # Download grafana dashboard to prometheus data for github stats
            cd /opt/${{ env.GIT_MONITOR }}/grafana || mkdir -p /opt/${{ env.GIT_MONITOR }}/grafana && cd /opt/${{ env.GIT_MONITOR }}/grafana
            cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning || mkdir -p /opt/${{ env.GIT_MONITOR }}/grafana/provisioning && cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning
            cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning/datasources || mkdir -p /opt/${{ env.GIT_MONITOR }}/grafana/provisioning/datasources && cd /opt/${{ env.GIT_MONITOR }}/grafana/provisioning/datasources
            rm datasource.yml
            # Download dashboard config for grafana
            if [ ! -f datasource.yml ]; then 
              curl -o datasource.yml https://raw.githubusercontent.com/obsidionz/build-test-contain/${{ github.ref_name }}/grafana/datasource.yml
              cd ../../..
            fi
            export GHCR_TOK="${{ secrets.GHCR_PAT }}"
            echo "$GHCR_TOK" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
            GHCR_TOK=
            # Pull latest image
            docker compose -f docker-compose-monitor.yml --env-file .env pull

            # Stop and remove old containers
            docker compose -f docker-compose-monitor.yml --env-file .env down

            # Start new containers
            docker compose -f docker-compose-monitor.yml --env-file .env up -d

            # Clean up old images
            docker image prune -f
